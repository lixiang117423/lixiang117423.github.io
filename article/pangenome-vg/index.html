

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="李详【Xiang LI】">
  <meta name="keywords" content="">
  <meta name="google-site-verification" content="W0bd7QAXqv4_2p37UlvKzRbXgPQWZun5DbrUuQtdSI4">
  
    <meta name="description" content="vg：variation graph data structures, interchange formats, alignment, genotyping, and variant calling methods.  1 基础知识vg其实就是variation graph的缩写:),一个vg中有这些元素： 1.1 **Node**（节点） 定义：表示基因组中的一段序列片段，可以是：  核心基因（">
<meta property="og:type" content="article">
<meta property="og:title" content="泛基因组工具vg">
<meta property="og:url" content="https://lixiang117423.github.io/article/pangenome-vg/index.html">
<meta property="og:site_name" content="小蓝哥的知识荒原">
<meta property="og:description" content="vg：variation graph data structures, interchange formats, alignment, genotyping, and variant calling methods.  1 基础知识vg其实就是variation graph的缩写:),一个vg中有这些元素： 1.1 **Node**（节点） 定义：表示基因组中的一段序列片段，可以是：  核心基因（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/vgteam/vg/master/doc/figures/vg_logo_small.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/23014278/1740535629537-e5aa936a-9fcb-4d88-bce8-49ce0b1fa69e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/svg/23014278/1740563412069-f6598098-2736-4f30-9cab-c681e653054d.svg">
<meta property="article:published_time" content="2025-05-09T06:16:15.000Z">
<meta property="article:modified_time" content="2025-05-09T06:17:16.665Z">
<meta property="article:author" content="小蓝哥">
<meta property="article:tag" content="生物信息学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/vgteam/vg/master/doc/figures/vg_logo_small.png">
  
  
  
  <title>泛基因组工具vg - 小蓝哥的知识荒原</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lixiang117423.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="小蓝哥的知识荒原" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小蓝哥的知识荒原</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="泛基因组工具vg"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-09 14:16" pubdate>
          2025年5月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          62 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">泛基因组工具vg</h1>
            
            
              <div class="markdown-body">
                
                <p>vg：variation graph data structures, interchange formats, alignment, genotyping, and variant calling methods.</p>
<p><img src="https://raw.githubusercontent.com/vgteam/vg/master/doc/figures/vg_logo_small.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p><code>vg</code>其实就是<code>variation graph</code>的缩写:),一个<code>vg</code>中有这些元素：</p>
<h2 id="1-1-Node-（节点）"><a href="#1-1-Node-（节点）" class="headerlink" title="1.1 **Node**（节点）"></a>1.1 <code>**Node**</code><strong>（节点）</strong></h2><ul>
<li><p><strong>定义</strong>：表示基因组中的一段<strong>序列片段</strong>，可以是：</p>
</li>
<li><p>核心基因（所有个体共享的序列）。</p>
</li>
<li>可变基因或结构变异（如插入、缺失、倒位等）。</li>
<li><p>单核苷酸多态性（SNP）的不同等位形式。</p>
</li>
<li><p><strong>特点</strong>：</p>
</li>
<li><p>每个节点可能对应多个等位（allele），例如不同个体在同一位置的变异。</p>
</li>
<li>节点之间可以是连续的（如参考基因组的线性序列），也可以通过边连接非连续的变异区域。<br>  <strong>示例</strong>：<br>  在人类基因组中，一个节点可能代表某段DNA序列（如基因区域），而另一个节点可能代表该区域的SNP变异（如A→T）。</li>
</ul>
<hr>
<h2 id="1-2-Edge-（边）"><a href="#1-2-Edge-（边）" class="headerlink" title="1.2 **Edge**（边）"></a>1.2 <code>**Edge**</code><strong>（边）</strong></h2><ul>
<li><strong>定义</strong>：表示节点之间的<strong>连接关系</strong>，描述序列如何从一个节点过渡到另一个节点。</li>
<li><p><strong>特点</strong>：</p>
</li>
<li><p>边可以是<strong>物理相邻</strong>的连接（如参考基因组中相邻的序列）。</p>
</li>
<li>也可以表示<strong>变异路径</strong>（如不同等位或结构变异之间的选择）。</li>
<li>边可能带有权重（如变异频率）或标签（如变异类型）。<br>  <strong>示例</strong>：<br>  如果一个节点代表插入序列，另一个节点代表缺失，边可以表示两种变异之间的连接关系（如某个群体更倾向于携带插入）。</li>
</ul>
<hr>
<h2 id="1-3-Path-（路径）"><a href="#1-3-Path-（路径）" class="headerlink" title="1.3 **Path**（路径）"></a>1.3 <code>**Path**</code><strong>（路径）</strong></h2><ul>
<li><strong>定义</strong>：表示某个个体基因组在泛基因组图中的<strong>行走路径</strong>，由一系列节点和边组成，反映该个体的独特基因组序列。</li>
<li><p><strong>特点</strong>：</p>
</li>
<li><p>不同个体的路径可能不同，体现遗传多样性。</p>
</li>
</ul>
<ol>
<li>路径可以覆盖核心基因（所有个体共享）和可变基因（部分个体特有）。<br> <strong>示例</strong>：<br> 个体A的路径可能是：<code>节点1（参考序列）→ 节点2（SNP等位A）→ 节点3（插入序列）</code>，而个体B的路径可能是：<code>节点1→节点2（SNP等位T）→节点4（无插入）</code>。</li>
</ol>
<h2 id="1-4-三者关系与泛基因组的意义"><a href="#1-4-三者关系与泛基因组的意义" class="headerlink" title="1.4 三者关系与泛基因组的意义"></a>1.4 <strong>三者关系与泛基因组的意义</strong></h2><ul>
<li><strong>整合多样性</strong>：通过节点和边整合所有已知变异，避免传统线性参考基因组的单一性偏差。</li>
<li><strong>灵活表示</strong>：路径允许不同个体的基因组以不同方式遍历图结构，准确反映变异组合。</li>
<li><p><strong>应用场景</strong>：</p>
</li>
<li><p><strong>序列比对</strong>：将测序数据比对到泛基因组图，提高变异检测的准确性。</p>
</li>
<li><strong>进化分析</strong>：通过路径差异推断群体结构或进化关系。</li>
<li><strong>功能研究</strong>：关联特定路径（如携带某结构变异的路径）与表型。</li>
</ul>
<hr>
<h2 id="1-5-类比解释"><a href="#1-5-类比解释" class="headerlink" title="1.5 类比解释"></a>1.5 <strong>类比解释</strong></h2><p>将泛基因组图想象成<strong>地铁网络</strong>：</p>
<ul>
<li><strong>节点</strong> = 地铁站（不同的序列位置或变异）。</li>
<li><strong>边</strong> = 轨道（连接站点的路线，代表可能的序列过渡）。</li>
<li><strong>路径</strong> = 乘客的行程（个体基因组选择的具体路线，反映其遗传组成）。通过这种结构，泛基因组能够更全面、灵活地表示物种的遗传多样性，为精准基因组学分析提供基础。</li>
</ul>
<hr>
<p>如何通俗地理解<code>vg</code>这种泛基因组格式呢？下图可以很容易地看出来这种格式的特点。所有的序列都可以看成<code>node</code>，也就是一个“点”，这个点可以是一个<code>SNP</code>，也可以是一大段片段。如果某个<code>node</code>在所有的样品里面都存在，那么这些<code>node</code>就会都连接到这个<code>node</code>，如下图中的<code>20030</code>.；如果是单个存在的，就用一条单独的<code>edge</code>连接这个<code>node</code>和下一个<code>node</code>，就像下图黄色的这个序列一样，直接从<code>20030→2033</code>，也就是缺失了<code>20031</code>和<code>20032</code>这两个<code>nodes</code>；如果多个样品共享一个<code>node</code>的，只用一个<code>edge</code>即可，就像<code>2009→20030</code>一样。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/23014278/1740535629537-e5aa936a-9fcb-4d88-bce8-49ce0b1fa69e.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="1-6-vg的优势"><a href="#1-6-vg的优势" class="headerlink" title="1.6 vg的优势"></a>1.6 vg的优势</h2><p>使用paths可以保证每条序列都是唯一的，当有新的序列被添加进去以后不会影响原理的序列的空间坐标，保证了结果的稳定性。</p>
<hr>
<h1 id="2-安装方法"><a href="#2-安装方法" class="headerlink" title="2 安装方法"></a>2 安装方法</h1><p>Linux系统最好的安装方式就是使用编译好的版本，下载链接：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vgteam/vg/releases/latest">https://github.com/vgteam/vg/releases/latest</a></p>
<p>然后添加可执行权限即可：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ./vg<br></code></pre></td></tr></tbody></table></figure>
<p>测试是否安装成功：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./vg <span class="hljs-built_in">help</span><br></code></pre></td></tr></tbody></table></figure>
<p>输出下面的内容就是安装成功了：</p>
<figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs ada">vg: variation graph tool, version v1.<span class="hljs-number">63.1</span> <span class="hljs-string">"Boccaleone"</span><br><br>usage: ./vg &lt;command&gt; [options]<br><br>main mapping <span class="hljs-keyword">and</span> calling pipeline:<br>  <span class="hljs-comment">-- autoindex     mapping tool-oriented index construction from interchange formats</span><br>  <span class="hljs-comment">-- construct     graph construction</span><br>  <span class="hljs-comment">-- rna           construct splicing graphs and pantranscriptomes</span><br>  <span class="hljs-comment">-- index         index graphs or alignments for random access or mapping</span><br>  <span class="hljs-comment">-- map           MEM-based read alignment</span><br>  <span class="hljs-comment">-- giraffe       fast haplotype-aware short read alignment</span><br>  <span class="hljs-comment">-- mpmap         splice-aware multipath alignment of short reads</span><br>  <span class="hljs-comment">-- augment       augment a graph from an alignment</span><br>  <span class="hljs-comment">-- pack          convert alignments to a compact coverage index</span><br>  <span class="hljs-comment">-- call          call or genotype VCF variants</span><br>  <span class="hljs-comment">-- help          show all subcommands</span><br><br>useful graph tools:<br>  <span class="hljs-comment">-- deconstruct   create a VCF from variation in the graph</span><br>  <span class="hljs-comment">-- gbwt          build and manipulate GBWT and GBZ files</span><br>  <span class="hljs-comment">-- haplotypes    haplotype sampling based on kmer counts</span><br>  <span class="hljs-comment">-- ids           manipulate node ids</span><br>  <span class="hljs-comment">-- minimizer     build a minimizer index or a syncmer index</span><br>  <span class="hljs-comment">-- mod           filter, transform, and edit the graph</span><br>  <span class="hljs-comment">-- prune         prune the graph for GCSA2 indexing</span><br>  <span class="hljs-comment">-- sim           simulate reads from a graph</span><br>  <span class="hljs-comment">-- snarls        compute snarls and their traversals</span><br>  <span class="hljs-comment">-- stats         metrics describing graph and alignment properties</span><br>  <span class="hljs-comment">-- view          format conversions for graphs and alignments</span><br><br>specialized graph tools:<br>  <span class="hljs-comment">-- align         local alignment</span><br>  <span class="hljs-comment">-- annotate      annotate alignments with graphs and graphs with alignments</span><br>  <span class="hljs-comment">-- chunk         split graph or alignment into chunks</span><br>  <span class="hljs-comment">-- circularize   circularize a path within a graph</span><br>  <span class="hljs-comment">-- clip          remove BED regions (other other nodes from their snarls) from a graph</span><br>  <span class="hljs-comment">-- combine       merge multiple graph files together</span><br>  <span class="hljs-comment">-- convert       convert graphs between handle-graph compliant formats as well as GFA</span><br>  <span class="hljs-comment">-- depth         estimate sequencing depth</span><br>  <span class="hljs-comment">-- dotplot       generate the dotplot matrix from the embedded paths in an xg index</span><br>  <span class="hljs-comment">-- filter        filter reads</span><br>  <span class="hljs-comment">-- gamcompare    compare alignment positions</span><br>  <span class="hljs-comment">-- gampcompare   compare multipath alignment positions</span><br>  <span class="hljs-comment">-- gamsort       Sort a GAM/GAF file or index a sorted GAM file.</span><br>  <span class="hljs-comment">-- genotype      Genotype (or type) graphs, GAMS, and VCFs.</span><br>  <span class="hljs-comment">-- inject        lift over alignments for the graph</span><br>  <span class="hljs-comment">-- mask          Mask out sequences in a graph with N's</span><br>  <span class="hljs-comment">-- paths         traverse paths in the graph</span><br>  <span class="hljs-comment">-- primers       filter primers for low variation</span><br>  <span class="hljs-comment">-- simplify      graph simplification</span><br>  <span class="hljs-comment">-- surject       map alignments onto specific paths</span><br>  <span class="hljs-comment">-- trace         trace haplotypes</span><br>  <span class="hljs-comment">-- vectorize     transform alignments to simple ML-compatible vectors</span><br>  <span class="hljs-comment">-- viz           render visualizations of indexed graphs and read sets</span><br><br>developer commands:<br>  <span class="hljs-comment">-- benchmark     run and report on performance benchmarks</span><br>  <span class="hljs-comment">-- chain         run a serialized chaining problem</span><br>  <span class="hljs-comment">-- cluster       find and cluster mapping seeds</span><br>  <span class="hljs-comment">-- find          use an index to find nodes, edges, kmers, paths, or positions</span><br>  <span class="hljs-comment">-- mcmc          Finds haplotypes based on reads using MCMC methods</span><br>  <span class="hljs-comment">-- test          run unit tests</span><br>  <span class="hljs-comment">-- validate      validate the semantics of a graph or gam</span><br>  <span class="hljs-comment">-- version       version information</span><br>  <span class="hljs-comment">-- zipcode       find distances between seeds using zipcodes</span><br><br><span class="hljs-keyword">For</span> technical support, please visit: https://www.biostars.org/tag/vg/<br></code></pre></td></tr></tbody></table></figure>
<p><strong>如果使用conda安装PGGB的话</strong><a target="_blank" rel="noopener" href="https://www.yuque.com/web4xiang/paper/pggb" title="01.PGGB">01.PGGB</a><strong>，会自动安装上最新版本的vg.</strong></p>
<h1 id="3-快速上手"><a href="#3-快速上手" class="headerlink" title="3 快速上手"></a>3 快速上手</h1><h2 id="3-1-vg构建"><a href="#3-1-vg构建" class="headerlink" title="3.1 vg构建"></a>3.1 vg构建</h2><h3 id="3-1-1-从VCF文件构建"><a href="#3-1-1-从VCF文件构建" class="headerlink" title="3.1.1 从VCF文件构建"></a>3.1.1 从VCF文件构建</h3><p>这种方法直接使用参考基因组和VCF文件进行构建，就两个参数：</p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">vg construct -r small/<span class="hljs-keyword">x</span>.fa -v small/<span class="hljs-keyword">x</span>.vcf.gz &gt;<span class="hljs-keyword">x</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<p>需要注意的是需要使用SAMtools中的工具tavix对VCF文件构建索引：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tabix -<span class="hljs-selector-tag">p</span> vcf x<span class="hljs-selector-class">.vcf</span>.gz<br></code></pre></td></tr></tbody></table></figure>
<h3 id="3-1-2-从组装结果构建泛基因组"><a href="#3-1-2-从组装结果构建泛基因组" class="headerlink" title="3.1.2 从组装结果构建泛基因组"></a>3.1.2 从组装结果构建泛基因组</h3><p>可以直接使用组装后的基因组进行泛基因组组装，所用的方法是 <code>Minigraph-Cactus</code>：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ComparativeGenomicsToolkit/cactus/blob/master/doc/pangenome.md">https://github.com/ComparativeGenomicsToolkit/cactus/blob/master/doc/pangenome.md</a></p>
<h2 id="3-2-导入和导出不同格式的graph"><a href="#3-2-导入和导出不同格式的graph" class="headerlink" title="3.2 导入和导出不同格式的graph"></a>3.2 导入和导出不同格式的graph</h2><h3 id="3-2-1-vg支持的泛基因组格式"><a href="#3-2-1-vg支持的泛基因组格式" class="headerlink" title="3.2.1 vg支持的泛基因组格式"></a>3.2.1 vg支持的泛基因组格式</h3><ul>
<li><code>PackedGraph</code>（.vg）：这种格式是vg的原生格式，优点是可以编辑，但是样品数量足够多或者是泛基因组太复杂时效率不足，尤其是path较多时。</li>
<li><code>GFA</code>（.gfa）：GFA是一种标准的基于文本的格式，是vg和其他泛基因组工具之间处理数据时最好的格式。vg可以直接对未压缩的GFA文件进行操作，是PackedGraph将泛基因组导入到内存中进行操作的。</li>
<li><code>GBZ</code>（.gbz）：GBZ是一种高度压缩的格式，可以使用较少的空间存储更多的paths，但是呢不利于编辑等操作。</li>
</ul>
<p>可以使用下面的命令查看泛基因组的格式：</p>
<figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vg stats -F</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="3-2-2-导入泛基因组"><a href="#3-2-2-导入泛基因组" class="headerlink" title="3.2.2 导入泛基因组"></a>3.2.2 导入泛基因组</h3><p>通常情况下可以使用<code>vg autoindex</code>从<code>GFA</code>或者是<code>VCF</code>文件构建泛基因组并构建索引，或者是通过<code>Minigraph-Cactus</code>构建泛基因组并建立索引。此外，还可以使用<code>vg convert -g</code>从<code>ODGI</code>或<code>PGGB</code>等工具输出的结果中导入<code>GFA</code>格式的泛基因组。</p>
<h3 id="3-2-3-导出泛基因组"><a href="#3-2-3-导出泛基因组" class="headerlink" title="3.2.3 导出泛基因组"></a>3.2.3 导出泛基因组</h3><p>可以使用<code>vg convert -f</code>将任意格式的<code>grapha</code>转换为GFA格式。<code>vg</code>默认使用<code>V1.1</code>的<code>GFA</code>，<code>paths</code>用<code>W-lines</code>表示；如果使用<code>P-lines</code>的会需要<code>V1.0</code>的<code>GFA</code>，代码是<code>vg convert -fW</code>.</p>
<h3 id="3-2-4-Path类型"><a href="#3-2-4-Path类型" class="headerlink" title="3.2.4 Path类型"></a>3.2.4 Path类型</h3><p><code>GBZ</code>格式可以区分<code>REFERENCE</code>和<code>HAPLOTYPE</code>这两种paths. <code>REFERENCE</code>path可以作为坐标系统，但是需要更多的资源来存储结果。<code>HAPLOTYPE</code>这种path类型是高度压缩的，但是不能用于位置定位查找。在人类泛基因组中（HPRC），来自<code>GRCh38</code>和<code>CHM13</code>的contigs是<code>REFERENCE</code>path，其余样品的contigs是<code>HAPLOTYPE</code>path.</p>
<p>这两种path的区别被延续到<code>.vg</code>和<code>.gfa</code>格式中，以便想换转换和操作。在<code>.gfa</code>path中，<code>REFERENCE</code>path是<code>P-lines</code>或者是<code>W-lines</code>，对应的样品名称放在了好<code>header</code>中。但是在<code>HPLOTYPE</code>path的<code>W-lines</code>中，样品名称没有在<code>header</code>中。 在<code>.vg</code>中使用特定的命名约定来表示。</p>
<p>需要注意的是，如果想在<code>.vg</code>中加载大规模的<code>HAPLOTYPE</code>paths，只能用<code>GBZ</code>格式。<code>vg convert -H</code>可以把<code>HAPLOTYPE</code>paths移除。</p>
<h2 id="3-3-查看graph"><a href="#3-3-查看graph" class="headerlink" title="3.3 查看graph"></a>3.3 查看graph</h2><p>使用<code>vg view</code>可以把graph转换为多种格式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># GFA output</span><br>vg view x.vg &gt;x.gfa<br><br><span class="hljs-comment"># dot output suitable for graphviz</span><br>vg view -d x.vg &gt;x.dot<br><br><span class="hljs-comment"># And if you have a GAM file</span><br><span class="hljs-built_in">cp</span> small/x-s1337-n1.gam x.gam<br><br><span class="hljs-comment"># json version of binary alignments</span><br>vg view -a x.gam &gt;x.json<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3-4-Mapping"><a href="#3-4-Mapping" class="headerlink" title="3.4 Mapping"></a>3.4 Mapping</h2><p>vg中有多个模块可以用于mapping：</p>
<ul>
<li><code>vg giraffe</code>：适合高准确度的短reads，将这些reads比对到graph上，能够保留单倍型信息。</li>
<li><code>vg map</code>：常用的mapper.</li>
<li><code>vg mpmap</code>：可以实现<code>multi-path</code>mapping，以便对不确定的局部alignment进行描述。这种方法尤其适用于转录组数据。</li>
</ul>
<h3 id="3-4-1-vg-giraffe"><a href="#3-4-1-vg-giraffe" class="headerlink" title="3.4.1 vg giraffe"></a>3.4.1 <code>vg giraffe</code></h3><p>使用<code>vg giraffe</code>的第一步是构建索引，最佳方式是<code>vg autoindex</code>. 为了保证<code>vg autoindex</code>能够使用VCF文件中的单倍型信息，可以把VCF文件和对应的线性参考基因组同时给<code>vg autoindex</code>.</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># construct the graph and indexes (paths below assume running from `vg/test` directory)</span><br><span class="hljs-attribute">vg</span> autoindex --workflow giraffe -r small/x.fa -v small/x.vcf.gz -p x<br><br><span class="hljs-comment"># simulate a bunch of 150bp reads from the graph, into a GAM file of reads aligned to a graph</span><br><span class="hljs-attribute">vg</span> sim -n <span class="hljs-number">1000</span> -l <span class="hljs-number">150</span> -x x.giraffe.gbz -a &gt; x.sim.gam<br><span class="hljs-comment"># now re-map these reads against the graph, and get BAM output in linear space</span><br><span class="hljs-comment"># FASTQ input uses -f instead of -G.</span><br><span class="hljs-attribute">vg</span> giraffe -Z x.giraffe.gbz -G x.sim.gam -o BAM &gt; aln.bam<br></code></pre></td></tr></tbody></table></figure>
<h3 id="3-4-2-vg-map"><a href="#3-4-2-vg-map" class="headerlink" title="3.4.2 vg map"></a>3.4.2 <code>vg map</code></h3><p>如果泛基因组的graph表达，那么就需要使用<code>vg index</code>来存储graph，然后使用<code>vg map</code>进行比对。所构建的索引包括graph和特定大小的kmers. 在mapping的时候，可以使用任何比构建索引所用的kmers；当使用的kmers没有成功mapping时，会自动降低kmers来增加mapping的灵敏度。</p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vim"># construct the graph (paths below assume running from `vg/test` directory)<br>vg construct -r small/<span class="hljs-keyword">x</span>.fa -v small/<span class="hljs-keyword">x</span>.vcf.gz &gt; <span class="hljs-keyword">x</span>.vg<br><br># store the graph in the xg/gcsa <span class="hljs-built_in">index</span> pair<br>vg <span class="hljs-built_in">index</span> -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg -g <span class="hljs-keyword">x</span>.gcsa -<span class="hljs-keyword">k</span> <span class="hljs-number">16</span> <span class="hljs-keyword">x</span>.vg<br><br># align <span class="hljs-keyword">a</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">to</span> the indexed <span class="hljs-keyword">version</span> of the graph<br># note that the graph <span class="hljs-keyword">file</span> <span class="hljs-keyword">is</span> not opened, but <span class="hljs-keyword">x</span>.vg.<span class="hljs-built_in">index</span> <span class="hljs-keyword">is</span> assumed<br>vg <span class="hljs-keyword">map</span> -s CTACTGACAGCAGAAGTTTGCTGTGAAGATTAAATTAGGTGATGCTTG -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg -g <span class="hljs-keyword">x</span>.gcsa &gt; <span class="hljs-keyword">read</span>.gam<br><br># simulate <span class="hljs-keyword">a</span> bunch of <span class="hljs-number">150</span><span class="hljs-keyword">bp</span> reads from the graph, one per <span class="hljs-built_in">line</span><br>vg <span class="hljs-keyword">sim</span> -n <span class="hljs-number">1000</span> -<span class="hljs-keyword">l</span> <span class="hljs-number">150</span> -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg &gt; <span class="hljs-keyword">x</span>.<span class="hljs-keyword">sim</span>.txt<br># now <span class="hljs-keyword">map</span> these reads against the graph <span class="hljs-keyword">to</span> <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> GAM<br>vg <span class="hljs-keyword">map</span> -T <span class="hljs-keyword">x</span>.<span class="hljs-keyword">sim</span>.txt -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg -g <span class="hljs-keyword">x</span>.gcsa &gt; aln.gam<br><br># surject the alignments back into the reference space of sequence <span class="hljs-string">"x"</span>, yielding <span class="hljs-keyword">a</span> BAM <span class="hljs-keyword">file</span><br>vg surject -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg -<span class="hljs-keyword">b</span> aln.gam &gt; aln.bam<br><br># <span class="hljs-built_in">or</span> alternatively, surject them <span class="hljs-keyword">to</span> BAM in the <span class="hljs-keyword">call</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">map</span><br>vg <span class="hljs-keyword">sim</span> -n <span class="hljs-number">1000</span> -<span class="hljs-keyword">l</span> <span class="hljs-number">150</span> -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg &gt; <span class="hljs-keyword">x</span>.<span class="hljs-keyword">sim</span>.txt<br>vg <span class="hljs-keyword">map</span> -T <span class="hljs-keyword">x</span>.<span class="hljs-keyword">sim</span>.txt -<span class="hljs-keyword">x</span> <span class="hljs-keyword">x</span>.xg -g <span class="hljs-keyword">x</span>.gcsa --surject-<span class="hljs-keyword">to</span> bam &gt; aln.bam<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3-5-Graph-augmentation"><a href="#3-5-Graph-augmentation" class="headerlink" title="3.5 Graph augmentation"></a>3.5 Graph augmentation</h2><p>在mapping鉴定到的variation可以反向添加到graph中，这个过程叫做Augmentation（增强）。但是需要注意的是<code>vg augment</code>用于变异鉴定的话还处于试验阶段，不稳定，官方的结果是这种方法不如<code>DeepVariant</code>等线性变异鉴定工具。</p>
<p><code>Warning</code> Using vg augment for variant calling remains very experimental. It is not at all recommended for structural variant calling, and even for small variants, you will often get much more accurate results (at least on human) by projecting your alignment to BAM and running a linear variant caller such as DeepVariant.</p>
<figure class="highlight golo"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-comment"># augment the graph with all variation from the GAM except that implied by soft clips, saving to aug.vg.  aug.gam contains the same reads as aln.gam but mapped to aug.vg</span><br>vg <span class="hljs-keyword">augment</span> x.vg aln.gam -A aug.gam &gt; aug.vg<br><br><span class="hljs-comment"># augment the graph with all variation from the GAM, saving each mapping as a path in the graph.</span><br><span class="hljs-comment"># softclips of alignment paths are preserved (`-S`).</span><br><span class="hljs-comment"># Note, this can be much less efficient than the above example if there are many alignments in the GAM</span><br>vg <span class="hljs-keyword">augment</span> x.vg aln.gam -i -S &gt; aug_with_paths.vg<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3-6-Variant-Calling"><a href="#3-6-Variant-Calling" class="headerlink" title="3.6 Variant Calling"></a>3.6 Variant Calling</h2><h3 id="3-6-1-read-support"><a href="#3-6-1-read-support" class="headerlink" title="3.6.1 read support"></a>3.6.1 read support</h3><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Compute the read support from the GAM</span><br><span class="hljs-comment"># -Q 5: ignore mapping and base qualitiy &lt; 5</span><br><span class="hljs-attribute">vg</span> pack -x x.xg -g aln.gam -Q <span class="hljs-number">5</span>  -o aln.pack<br><br><span class="hljs-comment"># Generate a VCF from the support.  </span><br><span class="hljs-attribute">vg</span> call x.xg -k aln.pack &gt; graph_calls.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>默认情况下<code>vg call</code>会忽略<code>0/0</code>这种类型的变异，这样可以让生成的VCF文件更加紧凑，但是不利于比较不同样本之间的差异。即使使用同一个graph得到的VCF文件也难以比较，因为坐标不同。<code>-a</code>参数可以解决这个问题，添加这个参数之后会对每个<code>snarl</code>进行比对，这时候使用的是相同的坐标体系。输出的结果可以使用<code>bcftools merge -m all</code>进行合并。</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg call x<span class="hljs-selector-class">.xg</span> -k aln<span class="hljs-selector-class">.pack</span> -<span class="hljs-selector-tag">a</span> &gt; snarl_genotypes.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>如果要考虑reads中新的变异的话，就需要使用augmented后的graph哥GAM.</p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"># Index our augmented graph<br>vg <span class="hljs-built_in">index</span> <span class="hljs-keyword">aug</span>.vg -<span class="hljs-keyword">x</span> <span class="hljs-keyword">aug</span>.xg<br><br># Compute the <span class="hljs-keyword">read</span> support from the augmented GAM (ignoring qualitiy &lt; <span class="hljs-number">5</span>, <span class="hljs-built_in">and</span> <span class="hljs-number">1</span><span class="hljs-keyword">st</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">last</span> <span class="hljs-number">5</span><span class="hljs-keyword">bp</span> of each <span class="hljs-keyword">read</span>)<br>vg pack -<span class="hljs-keyword">x</span> <span class="hljs-keyword">aug</span>.xg -g <span class="hljs-keyword">aug</span>.gam -Q <span class="hljs-number">5</span> -s <span class="hljs-number">5</span> -<span class="hljs-keyword">o</span> aln_aug.pack<br><br># Generate <span class="hljs-keyword">a</span> VCF from the support<br>vg <span class="hljs-keyword">call</span> <span class="hljs-keyword">aug</span>.xg -<span class="hljs-keyword">k</span> aln_aug.pack &gt; calls.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>可以使用类似的步骤对VCF文件中的已知的变异进行基因分型，有个要求是graph必须是使用<code>vg construct -a</code>构建的，<code>vg autoindex</code>和<code>Minigraph-Cactus</code>构建的graph不能用。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Re-construct the same graph as before but with `-a`</span><br>vg construct -r small/x.fa -v small/x.vcf.gz -a &gt; xa.vg<br><br><span class="hljs-comment"># Index the graph with `-L' to preserve alt paths in the xg</span><br>vg index xa.vg -x xa.xg -L<br><br><span class="hljs-comment"># Compute the support (we could also reuse aln.pack from above)</span><br>vg pack -x xa.xg -g aln.gam -o aln.pack<br><br><span class="hljs-comment"># Genotype the VCF (use -v)</span><br>vg call xa.xg -k aln.pack -v small/x.vcf.gz &gt; genotypes.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>在<code>Calling SNP</code>之间可以先对GAM进行预过滤处理：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># filter secondary and ambiguous read mappings out of the GAM</span><br><span class="hljs-attribute">vg</span> filter aln.gam -r <span class="hljs-number">0</span>.<span class="hljs-number">90</span> -fu -m <span class="hljs-number">1</span> -q <span class="hljs-number">15</span> -D <span class="hljs-number">999</span> -x x.xg &gt; aln.filtered.gam<br><br><span class="hljs-comment"># then compute the support from aln.filtered.gam instead of aln.gam in above etc.</span><br><span class="hljs-attribute">vg</span> pack -x xa.xg -g aln.filtered.gam -o aln.pack<br><span class="hljs-attribute">vg</span> call xa.xg -k aln.pack -v small/x.vcf.gz &gt; genotypes.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>如果graph较大，那么建议将<code>snarls</code>分开进行计算：</p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">vg snarls <span class="hljs-keyword">x</span>.xg &gt; <span class="hljs-keyword">x</span>.snarls<br><br># <span class="hljs-keyword">load</span> snarls from a file instead of computing on the fly<br>vg <span class="hljs-keyword">call</span> <span class="hljs-keyword">x</span>.xg -k aln.pack -r <span class="hljs-keyword">x</span>.snarls &gt; calls.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>注意：<code>vg augment</code>、<code>vg pack</code>、<code>vg call</code>和<code>vg snarls</code>可以对任意格式的graph进行处理，包括<code>.gfa</code>、<code>.vg</code>、<code>.xg</code>；还能处理<code>vg convert</code>转换后的graph；但是不能处理<code>augment</code>处理后的graph. <code>.vg</code>和<code>.gfa</code>组要最多的内存，graph较大时不建议使用这两种格式。<code>vg pack</code>输出的结果只能和用于构建它的grap一起施用，所以<code>vg pack x.vg -g aln.gam -o x.pack</code>和<code>vg call x.xg -k x.pack</code>不能正常运行。</p>
<h3 id="3-6-2-Calling-variants-from-paths-in-the-graph"><a href="#3-6-2-Calling-variants-from-paths-in-the-graph" class="headerlink" title="3.6.2 Calling variants from paths in the graph"></a>3.6.2 Calling variants from paths in the graph</h3><p>一个从利用多个基因组比对结构构建的graph中Calling SVs的示例：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># create a graph from a multiple alignment of HLA haplotypes (from vg/test directory)</span><br><span class="hljs-attribute">vg</span> msga -f GRCh38_alts/FASTA/HLA/V-<span class="hljs-number">352962</span>.fa -t <span class="hljs-number">1</span> -k <span class="hljs-number">16</span> | vg mod -U <span class="hljs-number">10</span> - | vg mod -c - &gt; hla.vg<br><br><span class="hljs-comment"># index it</span><br><span class="hljs-attribute">vg</span> index hla.vg -x hla.xg<br><br><span class="hljs-comment"># generate a VCF using gi|568815592:29791752-29792749 as the reference contig.  The other paths will be considered as haploid samples</span><br><span class="hljs-attribute">vg</span> deconstruct hla.xg -e -p <span class="hljs-string">"gi|568815592:29791752-29792749"</span> &gt; hla_variants.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>基于<code>.gbz</code>或<code>.gbwt</code>索引的Haplotype paths可以分别使用参数<code>-z</code>和<code>-g</code>指定。使用<code>vg call</code>遇到较大的graph推荐将每个snarls分开计算，使用<code>-r</code>参数进行传参。</p>
<h2 id="3-7-转录组分析"><a href="#3-7-转录组分析" class="headerlink" title="3.7 转录组分析"></a>3.7 转录组分析</h2><p><code>vg</code>有一些工具可以用于转录组分析，需要用到的是剪切过的graph，也就是将带有注释的剪切点以edges的格式添加到graph中，用到的命令是<code>vg rna</code>. 然后可以使用<code>vg mpmap</code>进行比对。针对单倍型比对定量的工具是<code>rpvg</code>. 最简单是反式就是使用<code>vg autoindex</code>为<code>vg mpmap</code>构建索引。</p>
<ul>
<li>首先构建剪切graph：</li>
</ul>
<figure class="highlight dsconfig"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># Create spliced pangenome graph and indexes for vg mpmap</span><br><span class="hljs-string">vg</span> <span class="hljs-string">autoindex</span> <span class="hljs-built_in">--workflow</span> <span class="hljs-string">mpmap</span> -<span class="hljs-string">t</span> <span class="hljs-string">4</span> <span class="hljs-built_in">--prefix</span> <span class="hljs-string">vg_rna</span> <span class="hljs-built_in">--ref-fasta</span> <span class="hljs-string">small</span>/<span class="hljs-string">x</span>.<span class="hljs-string">fa</span> <span class="hljs-built_in">--vcf</span> <span class="hljs-string">small</span>/<span class="hljs-string">x</span>.<span class="hljs-string">vcf</span>.<span class="hljs-string">gz</span> <span class="hljs-built_in">--tx-gff</span> <span class="hljs-string">small</span>/<span class="hljs-string">x</span>.<span class="hljs-string">gtf</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>然后进行比对：</li>
</ul>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># Map simulated RNA-seq reads using vg mpmap</span><br>vg mpmap -n rna -t <span class="hljs-number">4</span> -x vg_rna.spliced.xg -g vg_rna.spliced.gcsa -d vg_rna.spliced.dist -f small<span class="hljs-regexp">/x_rna_1.fq -f small/</span>x_rna_2.fq &gt; mpmap.gamp<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3-8-Alignment"><a href="#3-8-Alignment" class="headerlink" title="3.8 Alignment"></a>3.8 Alignment</h2><p>如果graph较小，那么可以使用偏序比对将一条序列比对到graph上：</p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">vg <span class="hljs-keyword">align</span> -s CTACTGACAGCAGAAGTTTGCTGTGAAGATTAAATTAGGTGATGCTTG <span class="hljs-keyword">x</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<p>Note that you don’t have to store the graph on disk at all, you can simply pipe it into the local aligner:</p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">vg construct -r small/<span class="hljs-keyword">x</span>.fa -v small/<span class="hljs-keyword">x</span>.vcf.gz | vg <span class="hljs-keyword">align</span> -s CTACTGACAGCAGAAGTTTGCTGTGAAGATTAAATTAGGTGATGCTTG -<br></code></pre></td></tr></tbody></table></figure>
<h1 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4 常用命令"></a>4 常用命令</h1><ul>
<li><code>autoindex</code>: construct graphs and indexes for other tools from common interchange file formats</li>
<li><code>construct</code>: graph construction</li>
<li><code>index</code>: index features of a graph in a disk-backed key/value store</li>
<li><code>map</code>: map reads to a graph</li>
<li><code>giraffe</code>: fast, haplotype-based mapping of reads to a graph</li>
<li><code>mpmap</code>: short read mapping and multipath alignment (optionally spliced)</li>
<li><code>surject</code>: project graph alignments onto a linear reference</li>
<li><code>augment</code>: add variation from aligned reads into a graph</li>
<li><code>call</code>: call variants from an augmented graph</li>
<li><code>rna</code>: construct splicing graphs and pantranscriptomes</li>
<li><code>convert</code>: convert graph and alignment formats</li>
<li><code>combine</code>: combine graphs</li>
<li><code>chunk</code>: extract or break into subgraphs</li>
<li><code>ids</code>: node ID manipulation</li>
<li><code>sim</code>: simulate reads by walking paths in a graph</li>
<li><code>prune</code>: prune graphs to restrict their path complexity</li>
<li><code>snarls</code>: find bubble-like motifs in a graph</li>
<li><code>mod</code>: various graph transformations</li>
<li><code>filter</code>: filter reads out of an alignment</li>
<li><code>deconstruct</code>: create a VCF from variation in a graph</li>
<li><code>paths</code>: traverse paths in a graph</li>
<li><code>stats</code>: metrics describing graph properties</li>
</ul>
<hr>
<h1 id="5-文献引用"><a href="#5-文献引用" class="headerlink" title="5 文献引用"></a>5 文献引用</h1><ul>
<li>when using <code>vg</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1038/nbt.4227">https://doi.org/10.1038/nbt.4227</a></p>
<ul>
<li>when using <code>vg giraffe</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1126/science.abg8871">https://doi.org/10.1126/science.abg8871</a></p>
<ul>
<li>when SV genotyping with <code>vg call</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-020-1941-7">https://doi.org/10.1186/s13059-020-1941-7</a></p>
<ul>
<li>when using <code>GBZ</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1093/bioinformatics/btac656">https://doi.org/10.1093/bioinformatics/btac656</a></p>
<ul>
<li>when using <code>vg deconstruct</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1038/s41586-023-05896-x">https://doi.org/10.1038/s41586-023-05896-x</a></p>
<ul>
<li>when using <code>vg snarls</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1089/cmb.2017.0251">https://doi.org/10.1089/cmb.2017.0251</a></p>
<ul>
<li>when using <code>vg haplotypes</code> and/or <code>vg giraffe --haplotype-name</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://doi.org/10.1101/2023.12.13.571553">https://doi.org/10.1101/2023.12.13.571553</a></p>
<h1 id="6-详细Wiki"><a href="#6-详细Wiki" class="headerlink" title="6 详细Wiki"></a>6 详细Wiki</h1><h2 id="6-1-安装vg"><a href="#6-1-安装vg" class="headerlink" title="6.1 安装vg"></a>6.1 安装vg</h2><p>Linux编译的话推荐gcc-4.9及以上的版本。</p>
<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight q"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install build-essential git cmake pkg-config libncurses-<span class="hljs-built_in">dev</span> libbz2-<span class="hljs-built_in">dev</span>  \<br>                     protobuf-compiler libprotoc-<span class="hljs-built_in">dev</span> libjansson-<span class="hljs-built_in">dev</span> automake libtool \<br>                     jq bc rs curl unzip redland-utils librdf-<span class="hljs-built_in">dev</span> bison flex gawk \<br>                     lzma-<span class="hljs-built_in">dev</span> liblzma-<span class="hljs-built_in">dev</span> liblz4-<span class="hljs-built_in">dev</span> libffi-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>编译vg</li>
</ul>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --recursive https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/vgteam/</span>vg<br>cd vg<br>make -j <span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>Docker安装</li>
</ul>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker pull quay.io/vgteam/vg<br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> vgteam/vg<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6-2-vg相关的格式"><a href="#6-2-vg相关的格式" class="headerlink" title="6.2 vg相关的格式"></a>6.2 vg相关的格式</h2><h3 id="6-2-1-格式总览"><a href="#6-2-1-格式总览" class="headerlink" title="6.2.1 格式总览"></a>6.2.1 格式总览</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>名称</td>
<td>描述</td>
<td>扩展名</td>
<td>状态</td>
<td>备注</td>
</tr>
<tr>
<td>VG Protobuf</td>
<td>原始 vg 图格式</td>
<td>.vg</td>
<td>有条件使用</td>
<td>也可用于存储路径（路径不关联节点与边）。vg v1.40.0 中 vg construct 的默认输出格式（支持增量生成）。可通过 cat 拼接。通常为块 GZIP 压缩，但旧文件可能未压缩。格式为计数前缀的组，每组包含长度前缀的 Protobuf 消息，首个消息标记类型。</td>
</tr>
<tr>
<td>GBZ</td>
<td>“GBZ”图格式，通过样本单体型路径遍历压缩存储图</td>
<td>.gbz</td>
<td>推荐</td>
<td>整合存储图和海量单体型数据（无需额外 GBWT 文件）。内部由 GBWT 和 GBWTGraph 组成。无法存储未被单体型路径覆盖的边。</td>
</tr>
<tr>
<td>GFA</td>
<td>图形化片段组装（Graphical Fragment Assembly）：基于文本的图及路径存储格式。</td>
<td>.gfa</td>
<td>推荐（交换用）</td>
<td>vg 仅支持 GFA 1.x，不兼容 GFA 2。</td>
</tr>
<tr>
<td>HashGraph</td>
<td>基于哈希表的图格式（来自 libbdsg）</td>
<td>.hg, .vg</td>
<td>推荐</td>
<td>vg v1.40.0 多数子命令的默认输出格式。</td>
</tr>
<tr>
<td>PackedGraph</td>
<td>基于简洁数据结构的图格式（来自 libbdsg）</td>
<td>.pg, .vg</td>
<td>推荐（大图适用）</td>
<td>比 HashGraph 更节省空间，但速度较慢且复杂。</td>
</tr>
<tr>
<td>Memory-Mapped PackedGraph</td>
<td>支持增量磁盘读取的 PackedGraph 版本</td>
<td>.mpg?</td>
<td>试验性</td>
<td>可能未实际采用（GBZ 解决更重要的核心问题）。</td>
</tr>
<tr>
<td>ODGI (vg flavor)</td>
<td>“优化动态基因组/图实现”（ODGI）格式的 vg 兼容版本。</td>
<td>.odgi</td>
<td>已移除</td>
<td>旧版 libbdsg 实现的格式与 odgi 项目不兼容，故被移除。</td>
</tr>
<tr>
<td>XG</td>
<td>压缩的不可变图格式（名称无实际含义）。</td>
<td>.xg</td>
<td>有条件使用</td>
<td>PackedGraph 更优，但部分工具仍依赖旧版 XG。</td>
</tr>
<tr>
<td>GBWTGraph</td>
<td>将 GBWT 转译为图的补充文件（需结合 GBWT 文件使用）。</td>
<td>.gg</td>
<td>已弃用</td>
<td>仅存节点序列，需配合单体型 GBWT 文件使用。</td>
</tr>
<tr>
<td>VG JSON</td>
<td>VG Protobuf 的 JSON 版本（Protobuf 图对象转为 JSON）。</td>
<td>.json</td>
<td>有条件使用</td>
<td>适合通过 jq 分析小图，或导入不支持 libbdsg/libvgio 的工具。一般推荐用 GFA 替代。</td>
</tr>
<tr>
<td>Indexed VG Protobuf</td>
<td>带索引的有序 VG Protobuf 格式（支持随机访问）。</td>
<td>.sorted.vg</td>
<td>已弃用</td>
<td>从未普及，已被 Memory-Mapped PackedGraph 取代。</td>
</tr>
<tr>
<td>FASTA</td>
<td>存储 DNA 序列的 FASTA 格式</td>
<td>.fa, .fasta, .fna</td>
<td>推荐（线性参考）</td>
<td>vg 可将其构造为线性参考基因组。</td>
</tr>
</tbody>
</table>
</div>
<p><code>vg</code>的很多文件格式都不能直接查看，需要使用<code>vg view</code>等才能查看；还有一些为0或者是没有设置的值夜不会展示。</p>
<h3 id="6-2-2-格式框架"><a href="#6-2-2-格式框架" class="headerlink" title="6.2.2 格式框架"></a>6.2.2 格式框架</h3><p>在<code>vg</code>中，<code>.vg</code>表示graph，<code>.gam</code>表示reads alignment的结果。对graph，每个message是一部分graph；对reads，每一条message是一个alignment.</p>
<h3 id="6-2-3-vg格式"><a href="#6-2-3-vg格式" class="headerlink" title="6.2.3 .vg格式"></a>6.2.3 .vg格式</h3><p><code>.vg</code>格式是<code>HashGraph</code>、<code>PackedGraph</code>或<code>Protobuf graph</code> 三种graph的格式。这三种格式的graph都可以被vg调用。现在<code>.vg</code>格式用的较多的是<code>HashGraph</code>或<code>PackedGraph</code>. 可以使用<code>vg view</code>查看GFA格式文件，使用<code>graphviz</code>查看pdf中的graph. 此外，也可以使用<code>vg mod</code>来编辑graph，但是通常的操作是先建立索引再进行操作。</p>
<h3 id="6-2-4-graph术语"><a href="#6-2-4-graph术语" class="headerlink" title="6.2.4 graph术语"></a>6.2.4 graph术语</h3><ul>
<li><code>reference graph</code>：表示含有参考基因组和相对于参考基因组的变异信息的graph，一个FASTA文件+VCF文件。</li>
<li><code>flat graph</code>：只包含参考基因组的graph. 因为没有bubbles，所以叫<code>flat</code>.</li>
<li><code>augmented graph</code>：一个graph被reads mapping以后得到的graph. <code>augmented graph</code>是<code>vg genotype</code>的基础。</li>
<li><code>sample graph</code>：含有一个或多个样品的variation的graph. 例如几个组装的基因组构建的graph，或者是单样品的reads augmented的<code>flat graph</code>.</li>
</ul>
<h3 id="6-2-5-xg-XG-lightweight-graph-path-index"><a href="#6-2-5-xg-XG-lightweight-graph-path-index" class="headerlink" title="6.2.5 .xg (XG lightweight graph / path index)"></a>6.2.5 .xg (XG lightweight graph / path index)</h3><p>XG可以理解为用于构建索引的graph的轻量版。<code>.xg</code>包含graph的paths、nodes和edges，但是不包含对应的序列，也就是说graph的结构被保留下来，但是真实的序列被删除了。这种格式和原始格式之间的转换是很复杂的，但是使用时只需要记住：这种模式是用来查询用的，比如两个nodes之间的距离、获取相邻的两个nodes、计算nodes的degree，而所有的这些仅仅只是用到了原始graph的索引。<code>.xg</code>格式的索引可以用来mapping reads，也可以加速某些功能模块，这样就不用在原始的graph上进行操作。</p>
<h3 id="6-2-6-gcsa-GCSA-generalized-compressed-suffix-array-index"><a href="#6-2-6-gcsa-GCSA-generalized-compressed-suffix-array-index" class="headerlink" title="6.2.6 .gcsa (GCSA generalized compressed suffix array index)"></a>6.2.6 .gcsa (GCSA generalized compressed suffix array index)</h3><p><code>GCSA/GCSA2</code>索引和<code>bwq index</code>生成的<code>.sa</code>文件是一样的。这个文件里面包含一个后缀数组，可以快速查询特定序列在graph中的位置。我们可以使用这种方法将reads mapping到graph上，这时候就可以看到GSCA索引的出现。</p>
<h3 id="6-2-7-gam（vg的BAM文件）"><a href="#6-2-7-gam（vg的BAM文件）" class="headerlink" title="6.2.7 .gam（vg的BAM文件）"></a>6.2.7 .gam（vg的BAM文件）</h3><p><code>.gam</code>就是vg的<code>BAM</code>文件，包含了某个read mapping到graph上的相对位置。这种格式支持双末端的reads. 可以使用<code>vg view</code>查看。这种格式也可以转换为JSON格式：</p>
<ul>
<li>一行一个记录，可以是一个read，是一个JSON对象；</li>
<li>当一个值是<code>0/NULL/false</code>时不存储在JSON文件中。</li>
</ul>
<h3 id="6-2-8-gam-index-GAM-索引）"><a href="#6-2-8-gam-index-GAM-索引）" class="headerlink" title="6.2.8 .gam.index (GAM 索引）"></a>6.2.8 .gam.index (GAM 索引）</h3><p><code>GAM</code>问价有个问题就是没有隐含的序列顺序。可以使用GAM索引来查询reads，这样就不用遍历整个GAM文件。也就是说当我们想提取mapping到特定位置的所有reads或者根据位置来排序reads，那就可以用GAM索引。</p>
<p>GAM索引的本质是一个RocksDB数据库。这样的好处是不用讲GAM文件放入到内存中，而是存在磁盘上，这样的一个坏处是可能速度较慢。</p>
<h3 id="6-2-9-dot（DOT-format-for-graphtools-viz）"><a href="#6-2-9-dot（DOT-format-for-graphtools-viz）" class="headerlink" title="6.2.9 .dot（DOT format for graphtools viz）"></a>6.2.9 .dot（DOT format for graphtools viz）</h3><p>DOT是graph可视化工具graphtools的标准格式，可以直观地读取，但是这种文件最大的用处是作为<code>vg</code>和PDF或SVG的中间文件。</p>
<h3 id="6-2-10-GFA（Graph-Fragment-Assembly-format）"><a href="#6-2-10-GFA（Graph-Fragment-Assembly-format）" class="headerlink" title="6.2.10 GFA（Graph Fragment / Assembly format）"></a>6.2.10 GFA（Graph Fragment / Assembly format）</h3><p>GFA可以方便graph数据在不同的程序之间来回交换，包括比对工具、泛基因组工具和可视化工具等。应该说GFA就是构建graph-based工具的关键。另外一个优势是GFA是可读的。</p>
<h3 id="6-2-11-vg扩展到GFA"><a href="#6-2-11-vg扩展到GFA" class="headerlink" title="6.2.11 vg扩展到GFA"></a>6.2.11 vg扩展到GFA</h3><p>vg能够调用GFA和RGFA文件，vg也能支持一些非标准的GFA标准。其中一个就是GFA头部的<code>RS</code>标签，vg将这个解释为空格分隔的参考样本。</p>
<h3 id="6-2-12-矢量化"><a href="#6-2-12-矢量化" class="headerlink" title="6.2.12 矢量化"></a>6.2.12 矢量化</h3><p>使用<code>vg vectorize</code>构建用于机器学习的向量化输出。</p>
<h2 id="6-3-基础用法"><a href="#6-3-基础用法" class="headerlink" title="6.3 基础用法"></a>6.3 基础用法</h2><h3 id="6-3-1-用法总览"><a href="#6-3-1-用法总览" class="headerlink" title="6.3.1 用法总览"></a>6.3.1 用法总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/svg/23014278/1740563412069-f6598098-2736-4f30-9cab-c681e653054d.svg" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"># 构建<br>vg construct -r reference<span class="hljs-selector-class">.fa</span> -v variants<span class="hljs-selector-class">.vcf</span><span class="hljs-selector-class">.gz</span> &gt; graph<span class="hljs-selector-class">.vg</span> <br><br># 索引<br>vg index -x graph<span class="hljs-selector-class">.xg</span> -g graph<span class="hljs-selector-class">.gcsa</span> graph<span class="hljs-selector-class">.vg</span> <br><br># 比对<br>vg map -f reads<span class="hljs-selector-class">.fq</span> -g graph<span class="hljs-selector-class">.gcsa</span> -x reads<span class="hljs-selector-class">.xg</span> &gt; mapped<span class="hljs-selector-class">.gam</span><br><br># 增强<br>vg augment -<span class="hljs-selector-tag">a</span> pileup -Z <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.trans</span> -S <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.support</span> graph<span class="hljs-selector-class">.vg</span> mapped<span class="hljs-selector-class">.gam</span> &gt; <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.aug</span><span class="hljs-selector-class">.vg</span> <br><br># Calling<br>vg call -z <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.trans</span> -s <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.support</span> <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.aug</span><span class="hljs-selector-class">.vg</span> &gt; calls<span class="hljs-selector-class">.vcf</span> <br></code></pre></td></tr></tbody></table></figure>
<h3 id="6-3-2-构建泛基因组"><a href="#6-3-2-构建泛基因组" class="headerlink" title="6.3.2 构建泛基因组"></a>6.3.2 构建泛基因组</h3><p>在vg中构建泛基因组通常有两种方法，如果有参考基因组，直接使用<code>vg construct</code>即可。可以只使用一个参考基因组构建graph，这样构建的graph是没有bubbles，因为是自己比对到自己，所以不会产生bubbles.</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">vg construct -r <span class="hljs-keyword">reference</span>.fa &gt; <span class="hljs-keyword">ref</span>.vg <span class="hljs-comment"># a 'flat' graph, in vg parlance. One that contains no bubbles.</span><br></code></pre></td></tr></tbody></table></figure>
<p>但如果只是构建这样的一个graph，那没啥意思，bwa也可以完成这个工作。真正需要的是利用一些先验信息（例如VCF文件中的变异信息）来mapping目的reads，这样做的目的是能够获得更好的mapping结果同时重新发现一些已知的变异。如果有一个使用了这个基因组得到的VCF文件，那么就可以构建这样的graph. 构建之前需要先压缩VCF文件并构建索引：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bgzip variants<span class="hljs-selector-class">.vcf</span> &amp;&amp; tabix variants<span class="hljs-selector-class">.vcf</span>.gz<br></code></pre></td></tr></tbody></table></figure>
<p>然后开售构建graph：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg construct -r reference<span class="hljs-selector-class">.fa</span> -v <span class="hljs-selector-tag">var</span><br>iants<span class="hljs-selector-class">.vcf</span><span class="hljs-selector-class">.gz</span> &gt; graph.vg<br></code></pre></td></tr></tbody></table></figure>
<p>需要注意的是这一步同样需要构建参考基因组的索引，如果没有索引文件的话vg会自动创建。</p>
<p>可以使用<code>-R</code>参数指定对哪条染色体进行graph构建。理论上来说只要是 <code>samtools-format region specifier</code>都可以，但是通常是针对整条染色体进行构建。下面的代码是对人类基因组的染色体分批进行graph构建：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ref=hs37d5.fa<br>vars=ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz<br><br><span class="hljs-built_in">echo</span> constructing graph<br>(<span class="hljs-built_in">seq</span> 1 22; <span class="hljs-built_in">echo</span> X; <span class="hljs-built_in">echo</span> Y) | parallel -j 24 <span class="hljs-string">"time vg construct -C -R {} -r <span class="hljs-variable">$ref</span> -v <span class="hljs-variable">$vars</span> -t 1 -m 32 &gt;{}.vg"</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="6-3-3-vg-msga替换vg-construct"><a href="#6-3-3-vg-msga替换vg-construct" class="headerlink" title="6.3.3 vg msga替换vg construct"></a>6.3.3 vg msga替换vg construct</h3><p>如果没有参考基因组，但是有polished的long reads，这时可以考虑使用<code>vg msga</code>进行逐步组装并构建graph：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vg</span> msga -f polished_contigs.fa &gt; graph.vg<br></code></pre></td></tr></tbody></table></figure>
<p>具体实现的步骤如下：</p>
<ul>
<li>使用第一条read构建一个 <code>flat graph</code></li>
<li>将第二条read比对到这个graph上</li>
<li>合并新的paths</li>
<li>对graph重新构建索引并重复上两步步骤</li>
</ul>
<h3 id="6-3-4-构建graph索引"><a href="#6-3-4-构建graph索引" class="headerlink" title="6.3.4 构建graph索引"></a>6.3.4 构建graph索引</h3><p>对泛基因组的graph构建索引和线性基因组构建索引类似，之所以构建索引是为了在后续的mapping等过程中更有效地查找泛基因组中的相关序列。</p>
<h4 id="6-3-4-1-xg索引"><a href="#6-3-4-1-xg索引" class="headerlink" title="6.3.4.1 xg索引"></a>6.3.4.1 xg索引</h4><p><code>xg</code>格式的索引能够存储一个graph中的nodes、edges和paths. 构建完索引后就可以将graph加载到内存中进行mapping等处理，可以使用更少的内存和更少的时间，也可以更有效地查询graph中的paths. 构建的命令如下：</p>
<figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">vg index -x <span class="hljs-keyword">graph</span>.xg <span class="hljs-keyword">graph</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<h4 id="6-3-4-2-GCSA2索引"><a href="#6-3-4-2-GCSA2索引" class="headerlink" title="6.3.4.2 GCSA2索引"></a>6.3.4.2 GCSA2索引</h4><p>GCSA2是<code>Generalized Compressed Suffix Array</code>的标准，可以理解为graph BWT index，类似于bwa生成的索引。可以很快速地查询特定序列在graph中的位置。例如，如果我们想查看<code>GATTACA</code>这个序列是否存在于所构建的graph中，这时使用GCSA2索引就可以查询到这个序列在graph中的位置。构建GCSA2索引时需要一个基于<code>pruned de Bruijn graph</code>的kmer参数。可以使用下面的命令构建GCSA2索引：</p>
<figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">vg index -<span class="hljs-keyword">g</span> <span class="hljs-keyword">graph</span>.gcsa <span class="hljs-keyword">graph</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<p>运行这个代码会生成两个文件：<code>graph.gcsa</code>和<code>graph.gcsa.lcp</code>. 这两个文件必须都存在，才能保证后续使用时不报错。</p>
<p>针对大型且复杂的graph，例如1000个基因组构建的全基因组graph，就不可能使用所有的kmers来构建GCSA2索引。这种情况就需要在构建索引前先对graph进行修剪，保证每个复杂区域只有一个<code>non-combinatorially-exploding subgraph</code>.</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg prune -r graph<span class="hljs-selector-class">.vg</span> &gt; graph<span class="hljs-selector-class">.pruned</span><span class="hljs-selector-class">.vg</span><br>vg index -g graph<span class="hljs-selector-class">.gcsa</span> graph<span class="hljs-selector-class">.pruned</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<p>更多的使用方法参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vgteam/vg/wiki/Working-with-a-whole-genome-variation-graph">https://github.com/vgteam/vg/wiki/Working-with-a-whole-genome-variation-graph</a></p>
<h4 id="6-3-4-3-GBWT索引"><a href="#6-3-4-3-GBWT索引" class="headerlink" title="6.3.4.3 GBWT索引"></a>6.3.4.3 GBWT索引</h4><p>如果输入的VCF文件包含单倍型信息，那么可以将单倍型信息加入到GBWT索引中，以获得更多的信息。GBWT能够存储大量的单倍型信息。构建索引的方法类似于XG索引。GBET索引需要XG索引的信息，所以这两中格式的索引必须同步生成。</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg index -x graph<span class="hljs-selector-class">.xg</span> -G graph<span class="hljs-selector-class">.gbwt</span> -v variants<span class="hljs-selector-class">.vcf</span><span class="hljs-selector-class">.gz</span> graph.vg<br></code></pre></td></tr></tbody></table></figure>
<p>如果有了GBWT索引，那就可以对单倍型进行修剪处理来构建GCSA索引：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg prune -u -g graph<span class="hljs-selector-class">.gbwt</span> graph<span class="hljs-selector-class">.vg</span> &gt; graph<span class="hljs-selector-class">.pruned</span><span class="hljs-selector-class">.vg</span><br>vg index -g graph<span class="hljs-selector-class">.gcsa</span> graph<span class="hljs-selector-class">.pruned</span>.vg<br></code></pre></td></tr></tbody></table></figure>
<h3 id="6-3-5-Mapping-reads"><a href="#6-3-5-Mapping-reads" class="headerlink" title="6.3.5 Mapping reads"></a>6.3.5 Mapping reads</h3><p>vg的mapping算法是MEM（maximal exact match），对应的模块是<code>vg map</code>. 不同的输入数据使用不同的命令，需要xg和GCSA这两种格式的索引，如果有GBWT索引的话也可以加入到其中，命令为<code>--gbwt-name graph.gbwt</code>.</p>
<figure class="highlight oxygene"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">## Single <span class="hljs-keyword">end</span> reads <span class="hljs-keyword">in</span> a single FASTQ<br>vg map -x <span class="hljs-keyword">index</span>.xg -g <span class="hljs-keyword">index</span>.gcsa -f reads.fq &gt; <span class="hljs-keyword">mapped</span>.gam<br>## Paired <span class="hljs-keyword">end</span> reads interleaved <span class="hljs-keyword">in</span> a single FASTQ<br>vg map -x <span class="hljs-keyword">index</span>.xg -g <span class="hljs-keyword">index</span>.gcsa -f reads.fq -i &gt; <span class="hljs-keyword">mapped</span>.gam<br>## Paired <span class="hljs-keyword">end</span> reads <span class="hljs-keyword">in</span> paired FASTQs<br>vg map -x <span class="hljs-keyword">index</span>.xg -g <span class="hljs-keyword">index</span>.gcsa -f reads1.fq -f reads2.fq &gt; <span class="hljs-keyword">mapped</span>.gam<br></code></pre></td></tr></tbody></table></figure>
<h3 id="6-3-6-Calling-variants"><a href="#6-3-6-Calling-variants" class="headerlink" title="6.3.6 Calling variants"></a>6.3.6 Calling variants</h3><h4 id="6-3-6-1-vg-call"><a href="#6-3-6-1-vg-call" class="headerlink" title="6.3.6.1 vg call"></a>6.3.6.1 vg call</h4><p><code>vg call</code>依赖于<code>samtools pileup</code>格式结构，是vg中推荐的方法。实现这个方法的本质是先对graph进行增强，再使用augmented的graph来生成变异图谱。</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg augment -<span class="hljs-selector-tag">a</span> pileup -Z <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.trans</span> -S <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.support</span> graph<span class="hljs-selector-class">.vg</span> mapped<span class="hljs-selector-class">.gam</span> &gt; <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.aug</span><span class="hljs-selector-class">.vg</span><br>vg call -z <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.trans</span> -s <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.support</span> <span class="hljs-selector-tag">samp</span><span class="hljs-selector-class">.aug</span><span class="hljs-selector-class">.vg</span> &gt; calls.vcf<br></code></pre></td></tr></tbody></table></figure>
<h4 id="6-3-6-2-vg-genotype"><a href="#6-3-6-2-vg-genotype" class="headerlink" title="6.3.6.2 vg genotype"></a>6.3.6.2 vg genotype</h4><p><code>vg genotype</code>使用类似FreeBayes的方法，但是得到的结果并不是很准确。第一步先对GAM文件构建索引，然后再识别鉴定变异。</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg index -d mapped<span class="hljs-selector-class">.gam</span><span class="hljs-selector-class">.index</span> -N mapped<span class="hljs-selector-class">.gam</span><br>vg genotype -v graph<span class="hljs-selector-class">.vg</span> mapped<span class="hljs-selector-class">.gam</span>.index/ &gt; calls.vcf<br></code></pre></td></tr></tbody></table></figure>
<p>生成的VCF文件是未排序的，需要使用vcflib对其进行排序。</p>
<h1 id="7-Mapping-long-reads-with-Giraffe"><a href="#7-Mapping-long-reads-with-Giraffe" class="headerlink" title="7 Mapping long reads with Giraffe"></a>7 Mapping long reads with Giraffe</h1><p>使用<code>vg giraffe</code>进行长reads比对。</p>
<h2 id="7-1-构建索引"><a href="#7-1-构建索引" class="headerlink" title="7.1 构建索引"></a>7.1 构建索引</h2><p>虽然<code>vg giraffe</code>会自动构建索引，但是还是建议预先构建对应的索引文件：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg autoindex <span class="hljs-attr">--workflow</span> lr-giraffe <span class="hljs-attr">--prefix</span> hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span> <span class="hljs-attr">--gbz</span> hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span>.gbz<br></code></pre></td></tr></tbody></table></figure>
<p>会生成这样一些文件：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.dist</span><br>hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span><br>hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.longread</span><span class="hljs-selector-class">.withzip</span><span class="hljs-selector-class">.min</span><br>hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.longread</span>.zipcodes<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>.dist</code>：距离索引</li>
<li><code>.gbz</code>：gbz格式的索引</li>
<li><code>.longread.withzip.min</code>：the “minimizers” used to find seeds, with embedded “zipcodes”</li>
<li><code>.longread.zipcodes</code>：the zipcodes too large to store in the minimizer file</li>
</ul>
<h2 id="7-2-Mapping"><a href="#7-2-Mapping" class="headerlink" title="7.2 Mapping"></a>7.2 Mapping</h2><p>针对不同测序方法得到的数据，使用参数<code>-b</code>指定测序数据类型，PacBio HiFi的数据使用<code>hifi</code>，Oxford Nanopore R10 chemistry reads使用<code>r10</code>；<code>-Z</code>参数指定<code>.gbz</code>格式的graph文件；<code>-f</code>参数指定输入的数据类型为<code>FASTQ</code>；使用参数<code>-p</code>来展示运行过程中的信息；使用<code>&gt;</code>将比对的结果输出为<code>.gam</code>格式。</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">b</span> hifi -Z hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> -f longread/hifi<span class="hljs-selector-class">.fq</span> -<span class="hljs-selector-tag">p</span> &gt;hifi<span class="hljs-selector-class">.mapped</span>.gam<br></code></pre></td></tr></tbody></table></figure>
<p>Giraffe能够从<code>.gbz</code>格式的graph中准确找到长reads的索引信息，如果没有相关的索引就会自动创建对应的索引。另外一个方法是直接把上一步生成的索引文件以传参的方式传入： <code>--minimizer-name/-m</code>、<code>--zipcode-name/-z</code>和<code>--dist-name/-d</code>.</p>
<p>Giraffe会自动预测使用多少线程来mapping，当然也可以使用<code>-t</code>参数指定mapping时所用的线程数。</p>
<h2 id="7-3-Mapping其他格式"><a href="#7-3-Mapping其他格式" class="headerlink" title="7.3 Mapping其他格式"></a>7.3 Mapping其他格式</h2><p>如果想要输出的格式为GAF格式，就使用<code>-o</code>参数进行指定：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">b</span> hifi -Z hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> -f longread/hifi<span class="hljs-selector-class">.fq</span> -<span class="hljs-selector-tag">p</span> -o GAF &gt;hifi<span class="hljs-selector-class">.mapped</span>.gaf<br></code></pre></td></tr></tbody></table></figure>
<p>如果想要输出线性的BAM文件，那么可以使用<code>-P</code>进行指定：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">b</span> hifi -Z hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> -f longread/hifi<span class="hljs-selector-class">.fq</span> -<span class="hljs-selector-tag">p</span> -o BAM -P &gt;hifi<span class="hljs-selector-class">.mapped</span>.bam<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7-4-处理Long-Read-Alignments"><a href="#7-4-处理Long-Read-Alignments" class="headerlink" title="7.4 处理Long Read Alignments"></a>7.4 处理Long Read Alignments</h2><h3 id="7-4-1-描述性统计信息"><a href="#7-4-1-描述性统计信息" class="headerlink" title="7.4.1 描述性统计信息"></a>7.4.1 描述性统计信息</h3><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg stats -<span class="hljs-selector-tag">a</span> hifi<span class="hljs-selector-class">.mapped</span>.gam<br></code></pre></td></tr></tbody></table></figure>
<p>类似的输出结果：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Total</span> alignments: <span class="hljs-number">1</span><br><span class="hljs-attribute">Total</span> primary: <span class="hljs-number">1</span><br><span class="hljs-attribute">Total</span> secondary: <span class="hljs-number">0</span><br><span class="hljs-attribute">Total</span> aligned: <span class="hljs-number">1</span><br><span class="hljs-attribute">Total</span> perfect: <span class="hljs-number">1</span><br><span class="hljs-attribute">Total</span> gapless (softclips allowed): <span class="hljs-number">1</span><br><span class="hljs-attribute">Total</span> paired: <span class="hljs-number">0</span><br><span class="hljs-attribute">Total</span> properly paired: <span class="hljs-number">0</span><br><span class="hljs-attribute">Alignment</span> score: mean <span class="hljs-number">15580</span>, median <span class="hljs-number">15580</span>, stdev <span class="hljs-number">0</span>, max <span class="hljs-number">15580</span> (<span class="hljs-number">1</span> reads)<br><span class="hljs-attribute">Mapping</span> quality: mean <span class="hljs-number">60</span>, median <span class="hljs-number">60</span>, stdev <span class="hljs-number">0</span>, max <span class="hljs-number">60</span> (<span class="hljs-number">1</span> reads)<br><span class="hljs-attribute">Insertions</span>: <span class="hljs-number">0</span> bp in <span class="hljs-number">0</span> read events<br><span class="hljs-attribute">Deletions</span>: <span class="hljs-number">0</span> bp in <span class="hljs-number">0</span> read events<br><span class="hljs-attribute">Substitutions</span>: <span class="hljs-number">0</span> bp in <span class="hljs-number">0</span> read events<br><span class="hljs-attribute">Softclips</span>: <span class="hljs-number">0</span> bp in <span class="hljs-number">0</span> read events<br><span class="hljs-attribute">Total</span> time: <span class="hljs-number">0</span>.<span class="hljs-number">00598654</span> seconds<br><span class="hljs-attribute">Speed</span>: <span class="hljs-number">167</span>.<span class="hljs-number">041</span> reads/second<br></code></pre></td></tr></tbody></table></figure>
<p>如果Mapping quality小于60的序列很多，那么就说明存在问题，需要检查序列质量。</p>
<h3 id="7-4-2-格式转换"><a href="#7-4-2-格式转换" class="headerlink" title="7.4.2 格式转换"></a>7.4.2 格式转换</h3><p>格式转换的时候需要graph文件。</p>
<h4 id="7-4-2-1-GAM转GAF"><a href="#7-4-2-1-GAM转GAF" class="headerlink" title="7.4.2.1 GAM转GAF"></a>7.4.2.1 GAM转GAF</h4><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg convert <span class="hljs-attr">--gam-to-gaf</span> hifi<span class="hljs-selector-class">.mapped</span><span class="hljs-selector-class">.gam</span> hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> &gt;hifi<span class="hljs-selector-class">.mapped</span>.gaf<br></code></pre></td></tr></tbody></table></figure>
<h4 id="7-4-2-2-GAF转GAM"><a href="#7-4-2-2-GAF转GAM" class="headerlink" title="7.4.2.2 GAF转GAM"></a>7.4.2.2 GAF转GAM</h4><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg convert <span class="hljs-attr">--gaf-to-gam</span> hifi<span class="hljs-selector-class">.mapped</span><span class="hljs-selector-class">.gaf</span> hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> &gt;hifi<span class="hljs-selector-class">.mapped</span>.gam<br></code></pre></td></tr></tbody></table></figure>
<h4 id="7-4-2-3-剥离GAM元数据"><a href="#7-4-2-3-剥离GAM元数据" class="headerlink" title="7.4.2.3 剥离GAM元数据"></a>7.4.2.3 剥离GAM元数据</h4><p>如果想用旧版本的vg或者是其他的非vg工具查看GAM文件的话，可能会得到下面的信息：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">what</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-attr">[vg::io::MessageIterator]</span> obsolete, invalid, or corrupt <span class="hljs-selector-tag">input</span> at message <span class="hljs-number">12345</span> group <span class="hljs-number">45678</span><br></code></pre></td></tr></tbody></table></figure>
<p>处理方法是将GAM转为GAF再转为GAM，这样就会把这些元数据去掉了。</p>
<h3 id="7-4-3-将长reads添加到BAM"><a href="#7-4-3-将长reads添加到BAM" class="headerlink" title="7.4.3 将长reads添加到BAM"></a>7.4.3 将长reads添加到BAM</h3><p>在有GMA或者是GAF格式文件后，如果想得到线性参考的BAM文件用于DeepVariant等软件，那么可以使用<code>vg surject</code>来surject比对结果并压缩为线性参考。对于长reads，在使用<code>vg surject</code>时需要添加<code>-prune-low-cplx/-p</code>参数，这样能够更好地处理跨越了串联重复等区域的reads.</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg surject -<span class="hljs-selector-tag">b</span> -x hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> hifi<span class="hljs-selector-class">.mapped</span><span class="hljs-selector-class">.gam</span> <span class="hljs-attr">--prune-low-cplx</span> &gt;hifi<span class="hljs-selector-class">.mapped</span>.bam<br></code></pre></td></tr></tbody></table></figure>
<p>如果是GAF文件，对应的命令为：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg surject -<span class="hljs-selector-tag">b</span> -x hprc-v1.<span class="hljs-number">1</span>-mc-chm13<span class="hljs-selector-class">.d9</span><span class="hljs-selector-class">.gbz</span> -G hifi<span class="hljs-selector-class">.mapped</span><span class="hljs-selector-class">.gaf</span> <span class="hljs-attr">--prune-low-cplx</span> &gt;hifi<span class="hljs-selector-class">.mapped</span>.bam<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7-5-最佳实践操作"><a href="#7-5-最佳实践操作" class="headerlink" title="7.5 最佳实践操作"></a>7.5 最佳实践操作</h2><p>短reads同样适用。</p>
<ul>
<li>双末端mapping（合二为一）</li>
</ul>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">p</span> -t <span class="hljs-number">32</span> -Z graph<span class="hljs-selector-class">.gbz</span> -d graph<span class="hljs-selector-class">.dist</span> -m graph<span class="hljs-selector-class">.min</span> \<br>    -<span class="hljs-selector-tag">i</span> -f reads<span class="hljs-selector-class">.fq</span><span class="hljs-selector-class">.gz</span> &gt; output.gam<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>双末端mapping</li>
</ul>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">p</span> -t <span class="hljs-number">32</span> -Z graph<span class="hljs-selector-class">.gbz</span> -d graph<span class="hljs-selector-class">.dist</span> -m graph<span class="hljs-selector-class">.min</span> \<br>    -f reads<span class="hljs-selector-class">.R1</span><span class="hljs-selector-class">.fq</span><span class="hljs-selector-class">.gz</span> -f reads<span class="hljs-selector-class">.R2</span><span class="hljs-selector-class">.fq</span><span class="hljs-selector-class">.gz</span> &gt; output.gam<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>双末端mapping后输出BAM文件</li>
</ul>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg giraffe -<span class="hljs-selector-tag">p</span> -t <span class="hljs-number">32</span> -Z graph<span class="hljs-selector-class">.gbz</span> -d graph<span class="hljs-selector-class">.dist</span> -m graph<span class="hljs-selector-class">.min</span> -x graph<span class="hljs-selector-class">.xg</span> \<br>    -<span class="hljs-selector-tag">i</span> -f reads<span class="hljs-selector-class">.fq</span><span class="hljs-selector-class">.gz</span> -o BAM &gt; output.bam<br></code></pre></td></tr></tbody></table></figure>
<h1 id="8-单倍型sampling"><a href="#8-单倍型sampling" class="headerlink" title="8 单倍型sampling"></a>8 单倍型sampling</h1><p>泛基因组graph作为参考进行比对时，嵌入到graph中的variation会影响mapping的结果。</p>
<ul>
<li>在graph和reads中都存在的variant会使mapping更准；</li>
<li>variant只存在于graph中但是不存在于reads中的话，mapping会很慢，准确度也不高。</li>
</ul>
<p>常见的是只使用共有的/常见的variant，但是后面开发出一个新的方法：对每个样品都构建一个个性化的reference. 这种方法是通过计算reads中的kmers，并根据kmer的数量来生成一个小的合成的单倍型。</p>
<h2 id="8-1-文献"><a href="#8-1-文献" class="headerlink" title="8.1 文献"></a>8.1 文献</h2><p><a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41592-024-02407-2">https://www.nature.com/articles/s41592-024-02407-2</a></p>
<h2 id="8-2-处理graph"><a href="#8-2-处理graph" class="headerlink" title="8.2 处理graph"></a>8.2 处理graph</h2><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vg index -j graph<span class="hljs-selector-class">.dist</span> <span class="hljs-attr">--no-nested-distance</span> graph<span class="hljs-selector-class">.gbz</span><br>vg gbwt -<span class="hljs-selector-tag">p</span> <span class="hljs-attr">--num-threads</span> <span class="hljs-number">16</span> -r graph<span class="hljs-selector-class">.ri</span> -Z graph<span class="hljs-selector-class">.gbz</span><br>vg haplotypes -v <span class="hljs-number">2</span> -t <span class="hljs-number">16</span> -H graph<span class="hljs-selector-class">.hapl</span> graph.gbz<br></code></pre></td></tr></tbody></table></figure>
<p>假设graph是由多个样本alignment后构建的，有着很高水平的线性结构，例如<code>Minigraph-Cactus pipeline</code>构建的graph。graph和单倍型必须是GBZ格式。预处理方法是将每条染色体切成长度为10 kbp的短序列，然后在其中选择最相关的单倍型，并将这些单倍型连接形成临时的合成单倍型；同时需要选择一些特定的kmers，通过这些kmers的存在和缺失来表示单倍型。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/" class="category-chain-item">生物信息学</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/" class="print-no-link">#生物信息学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>泛基因组工具vg</div>
      <div>https://lixiang117423.github.io/article/pangenome-vg/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>李详【Xiang LI】</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/article/bioinf2allin1/" title="我的生物信息学知识合集">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">我的生物信息学知识合集</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/article/pggb/" title="PGGB学习笔记">
                        <span class="hidden-mobile">PGGB学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      滇ICP备2021000708号-4
    </a>
  </span>
  
</div>

  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
